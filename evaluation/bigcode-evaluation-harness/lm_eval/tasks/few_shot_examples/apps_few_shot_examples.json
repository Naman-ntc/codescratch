{
    "base": [
        {
            "question": "You have $n$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $i$-th gift consists of $a_i$ candies and $b_i$ oranges.\n\nDuring one move, you can choose some gift $1 \\le i \\le n$ and do one of the following operations:\n\n  eat exactly one candy from this gift (decrease $a_i$ by one);  eat exactly one orange from this gift (decrease $b_i$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $a_i$ and $b_i$ by one). \n\nOf course, you can not eat a candy or orange if it's not present in the gift (so neither $a_i$ nor $b_i$ can become less than zero).\n\nAs said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $a_1 = a_2 = \\dots = a_n$ and $b_1 = b_2 = \\dots = b_n$ (and $a_i$ equals $b_i$ is not necessary).\n\nYour task is to find the minimum number of moves required to equalize all the given gifts.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) \u2014 the number of gifts. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of candies in the $i$-th gift. The third line of the test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 10^9$), where $b_i$ is the number of oranges in the $i$-th gift.\n\n\n-----Output-----\n\nFor each test case, print one integer: the minimum number of moves required to equalize all the given gifts.\n\n\n-----Example-----\nInput\n5\n3\n3 5 6\n3 2 3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n1 1 1\n2 2 2\n6\n1 1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1 1\n3\n10 12 8\n7 5 4\n\nOutput\n6\n16\n0\n4999999995\n7\n\n\n\n-----Note-----\n\nIn the first test case of the example, we can perform the following sequence of moves:\n\n  choose the first gift and eat one orange from it, so $a = [3, 5, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 4, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 3, 6]$ and $b = [2, 2, 3]$;  choose the third gift and eat one candy and one orange from it, so $a = [3, 3, 5]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 4]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 3]$ and $b = [2, 2, 2]$.",
            "answer": "import math\n\nT = int(input())\n\nfor i in range(T):\n  n = int(input())\n  #n,k = map(int, input().split())\n  a = list(map(int,input().split()))\n  b = list(map(int,input().split()))\n  #a = input()\n  d = False\n  \n  am = min(a)\n  bm = min(b)\n\n  ans = 0\n  for i in range(n):\n    ans += max(a[i]-am,b[i]-bm)\n  print(ans)"
        },
        {
            "question": "Given is an undirected connected graph with N vertices numbered 1 to N, and M edges numbered 1 to M.\nThe given graph may contain multi-edges but not self loops.\nEach edge has an integer label between 1 and N (inclusive).\nEdge i has a label c_i, and it connects Vertex u_i and v_i bidirectionally.\nSnuke will write an integer between 1 and N (inclusive) on each vertex (multiple vertices may have the same integer written on them) and then keep only the edges satisfying the condition below, removing the other edges.\nCondition: Let x and y be the integers written on the vertices that are the endpoints of the edge. Exactly one of x and y equals the label of the edge.\nWe call a way of writing integers on the vertices good if (and only if) the graph is still connected after removing the edges not satisfying the condition above. Determine whether a good way of writing integers exists, and present one such way if it exists.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - N-1 \\leq M \\leq 2 \\times 10^5\n - 1 \\leq u_i,v_i,c_i \\leq N\n - The given graph is connected and has no self-loops.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nu_1 v_1 c_1\n\\vdots\nu_M v_M c_M\n\n-----Output-----\nIf there is no good way of writing integers, print No.\nOtherwise, print N lines. The i-th line should contain the integer written on Vertex i.\nAny good way of writing integers will be accepted.\n\n-----Sample Input-----\n3 4\n1 2 1\n2 3 2\n3 1 3\n1 3 1\n\n-----Sample Output-----\n1\n2\n1\n\n - We write 1, 2, and 1 on Vertex 1, 2, and 3, respectively.\n - Edge 1 connects Vertex 1 and 2, and its label is 1.\n - Only the integer written on Vertex 1 equals the label, so this edge will not get removed.\n - Edge 2 connects Vertex 2 and 3, and its label is 2.\n - Only the integer written on Vertex 2 equals the label, so this edge will not be removed.\n - Edge 3 connects Vertex 1 and 3, and its label is 3.\n - Both integers written on the vertices differ from the label, so this edge will be removed.\n - Edge 4 connects Vertex 1 and 3, and its label is 1.\n - Both integers written on the vertices equal the label, so this edge will be removed.\n - After Edge 3 and 4 are removed, the graph will still be connected, so this is a good way of writing integers.",
            "answer": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\nN, M, *UVC = map(int, open(0).read().split())\n\nE = [[] for _ in range(N + 1)]\nfor u, v, c in zip(*[iter(UVC)] * 3):\n    E[u].append((v, c))\n    E[v].append((u, c))\n\nmemo = [-1] * (N + 1)\nmemo[1] = 1\n\ndef dfs(cur, par):\n    for nxt, c in E[cur]:\n        if memo[nxt] != -1 or nxt == par:\n            continue\n        if memo[cur] == c:\n            c = 1 + (c == 1)\n        memo[nxt] = c\n        dfs(nxt, cur)\n\ndfs(1, 0)\n\nfor m in memo[1:]:\n    print(m)"
        }
    ],
    "rename": [
        {
            "question": "You have $n$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $i$-th gift consists of $a_i$ candies and $b_i$ oranges.\n\nDuring one move, you can choose some gift $1 \\le i \\le n$ and do one of the following operations:\n\n  eat exactly one candy from this gift (decrease $a_i$ by one);  eat exactly one orange from this gift (decrease $b_i$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $a_i$ and $b_i$ by one). \n\nOf course, you can not eat a candy or orange if it's not present in the gift (so neither $a_i$ nor $b_i$ can become less than zero).\n\nAs said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $a_1 = a_2 = \\dots = a_n$ and $b_1 = b_2 = \\dots = b_n$ (and $a_i$ equals $b_i$ is not necessary).\n\nYour task is to find the minimum number of moves required to equalize all the given gifts.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) \u2014 the number of gifts. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of candies in the $i$-th gift. The third line of the test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 10^9$), where $b_i$ is the number of oranges in the $i$-th gift.\n\n\n-----Output-----\n\nFor each test case, print one integer: the minimum number of moves required to equalize all the given gifts.\n\n\n-----Example-----\nInput\n5\n3\n3 5 6\n3 2 3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n1 1 1\n2 2 2\n6\n1 1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1 1\n3\n10 12 8\n7 5 4\n\nOutput\n6\n16\n0\n4999999995\n7\n\n\n\n-----Note-----\n\nIn the first test case of the example, we can perform the following sequence of moves:\n\n  choose the first gift and eat one orange from it, so $a = [3, 5, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 4, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 3, 6]$ and $b = [2, 2, 3]$;  choose the third gift and eat one candy and one orange from it, so $a = [3, 3, 5]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 4]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 3]$ and $b = [2, 2, 2]$.",
            "answer": "import math\n\nt = int(input())\n\nfor _ in range(t):\n  n = int(input())\n  candies = list(map(int, input().split()))\n  oranges = list(map(int, input().split()))\n  \n  min_candies = min(candies)\n  min_oranges = min(oranges)\n\n  ans = 0\n  for i in range(n):\n    ans += max(candies[i] - min_candies, oranges[i] - min_oranges)\n  \n  print(ans)"
        },
        {
            "question": "Given is an undirected connected graph with N vertices numbered 1 to N, and M edges numbered 1 to M.\nThe given graph may contain multi-edges but not self loops.\nEach edge has an integer label between 1 and N (inclusive).\nEdge i has a label c_i, and it connects Vertex u_i and v_i bidirectionally.\nSnuke will write an integer between 1 and N (inclusive) on each vertex (multiple vertices may have the same integer written on them) and then keep only the edges satisfying the condition below, removing the other edges.\nCondition: Let x and y be the integers written on the vertices that are the endpoints of the edge. Exactly one of x and y equals the label of the edge.\nWe call a way of writing integers on the vertices good if (and only if) the graph is still connected after removing the edges not satisfying the condition above. Determine whether a good way of writing integers exists, and present one such way if it exists.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - N-1 \\leq M \\leq 2 \\times 10^5\n - 1 \\leq u_i,v_i,c_i \\leq N\n - The given graph is connected and has no self-loops.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nu_1 v_1 c_1\n\\vdots\nu_M v_M c_M\n\n-----Output-----\nIf there is no good way of writing integers, print No.\nOtherwise, print N lines. The i-th line should contain the integer written on Vertex i.\nAny good way of writing integers will be accepted.\n\n-----Sample Input-----\n3 4\n1 2 1\n2 3 2\n3 1 3\n1 3 1\n\n-----Sample Output-----\n1\n2\n1\n\n - We write 1, 2, and 1 on Vertex 1, 2, and 3, respectively.\n - Edge 1 connects Vertex 1 and 2, and its label is 1.\n - Only the integer written on Vertex 1 equals the label, so this edge will not get removed.\n - Edge 2 connects Vertex 2 and 3, and its label is 2.\n - Only the integer written on Vertex 2 equals the label, so this edge will not be removed.\n - Edge 3 connects Vertex 1 and 3, and its label is 3.\n - Both integers written on the vertices differ from the label, so this edge will be removed.\n - Edge 4 connects Vertex 1 and 3, and its label is 1.\n - Both integers written on the vertices equal the label, so this edge will be removed.\n - After Edge 3 and 4 are removed, the graph will still be connected, so this is a good way of writing integers.",
            "answer": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\nnum_vertices, num_edges, *UVC = map(int, open(0).read().split())\n\nedges = [[] for _ in range(num_vertices + 1)]\nfor u, v, c in zip(*[iter(UVC)] * 3):\n    edges[u].append((v, c))\n    edges[v].append((u, c))\n\nmemo = [-1] * (num_vertices + 1)\nmemo[1] = 1\n\ndef dfs(current_vertex, parent_vertex):\n    for next_vertex, label in edges[current_vertex]:\n        if memo[next_vertex] != -1 or next_vertex == parent_vertex:\n            continue\n        if memo[current_vertex] == label:\n            label = 1 + (label == 1)\n        memo[next_vertex] = label\n        dfs(next_vertex, current_vertex)\n\ndfs(1, 0)\n\nfor label in memo[1:]:\n    print(label)"
        }
    ],
    "modularize": [
        {
            "question": "You have $n$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $i$-th gift consists of $a_i$ candies and $b_i$ oranges.\n\nDuring one move, you can choose some gift $1 \\le i \\le n$ and do one of the following operations:\n\n  eat exactly one candy from this gift (decrease $a_i$ by one);  eat exactly one orange from this gift (decrease $b_i$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $a_i$ and $b_i$ by one). \n\nOf course, you can not eat a candy or orange if it's not present in the gift (so neither $a_i$ nor $b_i$ can become less than zero).\n\nAs said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $a_1 = a_2 = \\dots = a_n$ and $b_1 = b_2 = \\dots = b_n$ (and $a_i$ equals $b_i$ is not necessary).\n\nYour task is to find the minimum number of moves required to equalize all the given gifts.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) \u2014 the number of gifts. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of candies in the $i$-th gift. The third line of the test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 10^9$), where $b_i$ is the number of oranges in the $i$-th gift.\n\n\n-----Output-----\n\nFor each test case, print one integer: the minimum number of moves required to equalize all the given gifts.\n\n\n-----Example-----\nInput\n5\n3\n3 5 6\n3 2 3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n1 1 1\n2 2 2\n6\n1 1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1 1\n3\n10 12 8\n7 5 4\n\nOutput\n6\n16\n0\n4999999995\n7\n\n\n\n-----Note-----\n\nIn the first test case of the example, we can perform the following sequence of moves:\n\n  choose the first gift and eat one orange from it, so $a = [3, 5, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 4, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 3, 6]$ and $b = [2, 2, 3]$;  choose the third gift and eat one candy and one orange from it, so $a = [3, 3, 5]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 4]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 3]$ and $b = [2, 2, 2]$.",
            "answer": "def minimum_moves(t, test_cases):\n    for _ in range(t):\n        n = test_cases[_][0]\n        candies = test_cases[_][1]\n        oranges = test_cases[_][2]\n        min_candies = min(candies)\n        min_oranges = min(oranges)\n        ans = 0\n        for i in range(n):\n            ans += max(candies[i] - min_candies, oranges[i] - min_oranges)\n        print(ans)\n\n\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        candies = list(map(int, input().split()))\n        oranges = list(map(int, input().split()))\n        test_cases.append((n, candies, oranges))\n    minimum_moves(t, test_cases)\n\n\nmain()\n"
        },
        {
            "question": "Given is an undirected connected graph with N vertices numbered 1 to N, and M edges numbered 1 to M.\nThe given graph may contain multi-edges but not self loops.\nEach edge has an integer label between 1 and N (inclusive).\nEdge i has a label c_i, and it connects Vertex u_i and v_i bidirectionally.\nSnuke will write an integer between 1 and N (inclusive) on each vertex (multiple vertices may have the same integer written on them) and then keep only the edges satisfying the condition below, removing the other edges.\nCondition: Let x and y be the integers written on the vertices that are the endpoints of the edge. Exactly one of x and y equals the label of the edge.\nWe call a way of writing integers on the vertices good if (and only if) the graph is still connected after removing the edges not satisfying the condition above. Determine whether a good way of writing integers exists, and present one such way if it exists.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - N-1 \\leq M \\leq 2 \\times 10^5\n - 1 \\leq u_i,v_i,c_i \\leq N\n - The given graph is connected and has no self-loops.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nu_1 v_1 c_1\n\\vdots\nu_M v_M c_M\n\n-----Output-----\nIf there is no good way of writing integers, print No.\nOtherwise, print N lines. The i-th line should contain the integer written on Vertex i.\nAny good way of writing integers will be accepted.\n\n-----Sample Input-----\n3 4\n1 2 1\n2 3 2\n3 1 3\n1 3 1\n\n-----Sample Output-----\n1\n2\n1\n\n - We write 1, 2, and 1 on Vertex 1, 2, and 3, respectively.\n - Edge 1 connects Vertex 1 and 2, and its label is 1.\n - Only the integer written on Vertex 1 equals the label, so this edge will not get removed.\n - Edge 2 connects Vertex 2 and 3, and its label is 2.\n - Only the integer written on Vertex 2 equals the label, so this edge will not be removed.\n - Edge 3 connects Vertex 1 and 3, and its label is 3.\n - Both integers written on the vertices differ from the label, so this edge will be removed.\n - Edge 4 connects Vertex 1 and 3, and its label is 1.\n - Both integers written on the vertices equal the label, so this edge will be removed.\n - After Edge 3 and 4 are removed, the graph will still be connected, so this is a good way of writing integers.",
            "answer": "from sys import setrecursionlimit\n\n\ndef read_input():\n    (num_vertices, num_edges) = map(int, input().split())\n    UVC = [list(map(int, input().split())) for _ in range(num_edges)]\n    return (num_vertices, num_edges, UVC)\n\n\ndef build_graph(num_vertices, num_edges, UVC):\n    edges = [[] for _ in range(num_vertices + 1)]\n    for (u, v, c) in UVC:\n        edges[u].append((v, c))\n        edges[v].append((u, c))\n    return edges\n\n\ndef dfs(current_vertex, parent_vertex, edges, memo):\n    for (next_vertex, label) in edges[current_vertex]:\n        if memo[next_vertex] != -1 or next_vertex == parent_vertex:\n            continue\n        if memo[current_vertex] == label:\n            label = 1 + (label == 1)\n        memo[next_vertex] = label\n        dfs(next_vertex, current_vertex, edges, memo)\n\n\ndef write_labels(num_vertices, edges):\n    memo = [-1] * (num_vertices + 1)\n    memo[1] = 1\n    dfs(1, 0, edges, memo)\n    return memo[1:]\n\n\ndef main():\n    setrecursionlimit(10**6)\n    (num_vertices, num_edges, UVC) = read_input()\n    edges = build_graph(num_vertices, num_edges, UVC)\n    labels = write_labels(num_vertices, edges)\n    for label in labels:\n        print(label)\n\n\nmain()\n"
        }
    ],
    "plan": [
        {
            "question": "You have $n$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $i$-th gift consists of $a_i$ candies and $b_i$ oranges.\n\nDuring one move, you can choose some gift $1 \\le i \\le n$ and do one of the following operations:\n\n  eat exactly one candy from this gift (decrease $a_i$ by one);  eat exactly one orange from this gift (decrease $b_i$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $a_i$ and $b_i$ by one). \n\nOf course, you can not eat a candy or orange if it's not present in the gift (so neither $a_i$ nor $b_i$ can become less than zero).\n\nAs said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $a_1 = a_2 = \\dots = a_n$ and $b_1 = b_2 = \\dots = b_n$ (and $a_i$ equals $b_i$ is not necessary).\n\nYour task is to find the minimum number of moves required to equalize all the given gifts.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) \u2014 the number of gifts. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of candies in the $i$-th gift. The third line of the test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 10^9$), where $b_i$ is the number of oranges in the $i$-th gift.\n\n\n-----Output-----\n\nFor each test case, print one integer: the minimum number of moves required to equalize all the given gifts.\n\n\n-----Example-----\nInput\n5\n3\n3 5 6\n3 2 3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n1 1 1\n2 2 2\n6\n1 1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1 1\n3\n10 12 8\n7 5 4\n\nOutput\n6\n16\n0\n4999999995\n7\n\n\n\n-----Note-----\n\nIn the first test case of the example, we can perform the following sequence of moves:\n\n  choose the first gift and eat one orange from it, so $a = [3, 5, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 4, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 3, 6]$ and $b = [2, 2, 3]$;  choose the third gift and eat one candy and one orange from it, so $a = [3, 3, 5]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 4]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 3]$ and $b = [2, 2, 2]$.",
            "answer": "# <PLAN>\n# 1. `main()`: This function is the entry point of the program. It reads the number of test cases and the test case details from the input, and then calls the `minimum_moves()` function to compute and print the minimum number of moves required to equalize the gifts.\n# \n# 2. `minimum_moves(t, test_cases)`: This function takes two parameters - the number of test cases `t` and the list of test cases `test_cases`. For each test case, it computes the minimum number of moves required to equalize the gifts. It does this by finding the minimum number of candies and oranges in any gift, and then adding the difference between each gift's candy count and the minimum candy count, and each gift's orange count and the minimum orange count. Finally, it prints the answer for each test case.\n#\\</PLAN>\ndef minimum_moves(t, test_cases):\n    for _ in range(t):\n        n = test_cases[_][0]\n        candies = test_cases[_][1]\n        oranges = test_cases[_][2]\n        min_candies = min(candies)\n        min_oranges = min(oranges)\n        ans = 0\n        for i in range(n):\n            ans += max(candies[i] - min_candies, oranges[i] - min_oranges)\n        print(ans)\n\n\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        candies = list(map(int, input().split()))\n        oranges = list(map(int, input().split()))\n        test_cases.append((n, candies, oranges))\n    minimum_moves(t, test_cases)\n\n\nmain()\n"
        },
        {
            "question": "Given is an undirected connected graph with N vertices numbered 1 to N, and M edges numbered 1 to M.\nThe given graph may contain multi-edges but not self loops.\nEach edge has an integer label between 1 and N (inclusive).\nEdge i has a label c_i, and it connects Vertex u_i and v_i bidirectionally.\nSnuke will write an integer between 1 and N (inclusive) on each vertex (multiple vertices may have the same integer written on them) and then keep only the edges satisfying the condition below, removing the other edges.\nCondition: Let x and y be the integers written on the vertices that are the endpoints of the edge. Exactly one of x and y equals the label of the edge.\nWe call a way of writing integers on the vertices good if (and only if) the graph is still connected after removing the edges not satisfying the condition above. Determine whether a good way of writing integers exists, and present one such way if it exists.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - N-1 \\leq M \\leq 2 \\times 10^5\n - 1 \\leq u_i,v_i,c_i \\leq N\n - The given graph is connected and has no self-loops.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nu_1 v_1 c_1\n\\vdots\nu_M v_M c_M\n\n-----Output-----\nIf there is no good way of writing integers, print No.\nOtherwise, print N lines. The i-th line should contain the integer written on Vertex i.\nAny good way of writing integers will be accepted.\n\n-----Sample Input-----\n3 4\n1 2 1\n2 3 2\n3 1 3\n1 3 1\n\n-----Sample Output-----\n1\n2\n1\n\n - We write 1, 2, and 1 on Vertex 1, 2, and 3, respectively.\n - Edge 1 connects Vertex 1 and 2, and its label is 1.\n - Only the integer written on Vertex 1 equals the label, so this edge will not get removed.\n - Edge 2 connects Vertex 2 and 3, and its label is 2.\n - Only the integer written on Vertex 2 equals the label, so this edge will not be removed.\n - Edge 3 connects Vertex 1 and 3, and its label is 3.\n - Both integers written on the vertices differ from the label, so this edge will be removed.\n - Edge 4 connects Vertex 1 and 3, and its label is 1.\n - Both integers written on the vertices equal the label, so this edge will be removed.\n - After Edge 3 and 4 are removed, the graph will still be connected, so this is a good way of writing integers.",
            "answer": "# <PLAN>\n# 1. `main()`:\n# - This is the main function that reads input, builds the graph, and calls the `write_labels` function to determine the labels for each vertex.\n# - It sets the recursion limit to avoid stack overflow errors.\n# - It prints the labels for each vertex.\n# \n# 2. `write_labels(num_vertices, edges)`:\n# - This function determines the labels for each vertex in a connected graph.\n# - It initializes a memoization array to store the labels.\n# - It starts from vertex 1 and performs a depth-first search (DFS) to traverse the graph.\n# - During the DFS, it checks if the current vertex's label matches the label of the edge connecting it to the next vertex.\n# - If the labels match, it updates the label of the next vertex to be different from the current label.\n# - The function recursively calls itself to explore all connected vertices and updates their labels accordingly.\n# - Finally, it returns the labels for each vertex.\n# \n# 3. `read_input()`:\n# - This function reads the input from the standard input.\n# - It parses the number of vertices, number of edges, and the edges themselves.\n# - It returns a tuple containing the number of vertices, number of edges, and a list of edges.\n# \n# 4. `build_graph(num_vertices, num_edges, UVC)`:\n# - This function builds the graph representation from the given edges.\n# - It initializes an empty list of edges for each vertex.\n# - It loops through the edges and adds the corresponding edges to the graph representation.\n# - Each edge is added bidirectionally, connecting the two vertices and storing the label.\n# - The function returns the graph representation.\n# \n# 5. `dfs(current_vertex, parent_vertex, edges, memo)`:\n# - This function performs a depth-first search (DFS) on the graph.\n# - It starts from a given current vertex and explores its neighbors.\n# - It keeps track of the parent vertex to avoid revisiting it.\n# - It updates the memoization array with the labels of the vertices.\n# - If the label of the current vertex matches the label of an edge connecting it to a neighbor, the label of the neighbor is updated to be different.\n# - The function recursively calls itself to explore all connected vertices and updates their labels accordingly.\n#\\</PLAN>\nfrom sys import setrecursionlimit\n\n\ndef read_input():\n    (num_vertices, num_edges) = map(int, input().split())\n    UVC = [list(map(int, input().split())) for _ in range(num_edges)]\n    return (num_vertices, num_edges, UVC)\n\n\ndef build_graph(num_vertices, num_edges, UVC):\n    edges = [[] for _ in range(num_vertices + 1)]\n    for (u, v, c) in UVC:\n        edges[u].append((v, c))\n        edges[v].append((u, c))\n    return edges\n\n\ndef dfs(current_vertex, parent_vertex, edges, memo):\n    for (next_vertex, label) in edges[current_vertex]:\n        if memo[next_vertex] != -1 or next_vertex == parent_vertex:\n            continue\n        if memo[current_vertex] == label:\n            label = 1 + (label == 1)\n        memo[next_vertex] = label\n        dfs(next_vertex, current_vertex, edges, memo)\n\n\ndef write_labels(num_vertices, edges):\n    memo = [-1] * (num_vertices + 1)\n    memo[1] = 1\n    dfs(1, 0, edges, memo)\n    return memo[1:]\n\n\ndef main():\n    setrecursionlimit(10**6)\n    (num_vertices, num_edges, UVC) = read_input()\n    edges = build_graph(num_vertices, num_edges, UVC)\n    labels = write_labels(num_vertices, edges)\n    for label in labels:\n        print(label)\n\n\nmain()\n"
        }
    ]
}